|  | Principios de Programación                                 |
|---------------------|----------------------------------------------------------|
| Funcionalidad       | - [Principio de responsabilidad única (SRP)](https://en.wikipedia.org/wiki/Single-responsibility_principle): Cada clase o módulo debe tener una única responsabilidad. Esto facilita la comprensión y el mantenimiento del código, mejorando la funcionalidad. <br> - [Principio de apertura/cerrado (OCP)](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle): El código debe estar abierto para extenderse pero cerrado para modificarse. Esto permite agregar nuevas funcionalidades sin modificar el código existente. |
| Confiabilidad       | - [Principio de manejo de excepciones](https://en.wikipedia.org/wiki/Exception_handling): El código debe manejar adecuadamente las excepciones y errores para mantener la estabilidad del sistema y proporcionar retroalimentación al usuario. <br> - [Principio de diseño por contrato](https://en.wikipedia.org/wiki/Design_by_contract): Utilizar afirmaciones pre y postcondiciones para garantizar que los componentes interactúen de manera predecible y segura. |
| Usabilidad          | - [Principio de simplicidad](https://en.wikipedia.org/wiki/KISS_principle): Mantener el código simple y fácil de entender para facilitar el uso y la colaboración en el equipo. <br> - [Principio de nombre significativo](https://en.wikipedia.org/wiki/Meaningful_variable_names): Utilizar nombres de variables y funciones que reflejen claramente su propósito, mejorando la legibilidad y la comprensión del código. |
| Eficiencia          | - [Principio de minimización](https://en.wikipedia.org/wiki/Minimize_(software_implementation)): Reducir el uso innecesario de recursos, como ciclos de CPU o memoria, para mejorar la eficiencia del sistema. <br> - [Principio de optimización tardía](https://en.wikipedia.org/wiki/Program_optimization#When_to_optimize): Evitar la optimización prematura y centrarse en mantener un código limpio y legible hasta que se identifiquen puntos críticos de rendimiento. |
| Mantenibilidad      | - [Principio de código DRY (Don't Repeat Yourself)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself): Evitar la duplicación de código para facilitar su mantenimiento y evitar posibles errores. <br> - [Principio de separación de intereses (SoC)](https://en.wikipedia.org/wiki/Separation_of_concerns): Separar las preocupaciones y funcionalidades diferentes en módulos o clases independientes para facilitar las actualizaciones y mejoras. |
| Portabilidad        | - [Principio de abstracción de la plataforma](https://en.wikipedia.org/wiki/Platform_abstraction): Aislar el código de dependencias específicas de la plataforma para facilitar la portabilidad. <br> - [Principio de compatibilidad hacia atrás](https://en.wikipedia.org/wiki/Backward_compatibility): Mantener la compatibilidad con versiones anteriores para garantizar que el software se pueda ejecutar en diferentes entornos. |
| Seguridad           | - [Principio de mínimo privilegio](https://en.wikipedia.org/wiki/Principle_of_least_privilege): Conceder a cada componente o usuario solo los permisos necesarios para realizar sus funciones, reduciendo posibles vulnerabilidades. <br> - [Principio de validación de datos](https://en.wikipedia.org/wiki/Data_validation): Validar y sanitizar adecuadamente los datos de entrada para prevenir ataques como inyección de código. |
| Escalabilidad       | - [Principio de separación de preocupaciones (SoC)](https://en.wikipedia.org/wiki/Separation_of_concerns): Dividir la aplicación en componentes independientes que puedan escalarse individualmente. <br> - [Principio de paralelismo](https://en.wikipedia.org/wiki/Parallel_computing#Parallel_programming_models): Utilizar hilos o procesos paralelos para dividir la carga de trabajo y mejorar la escalabilidad. |
| Interoperabilidad   | - [Principio de abstracción de interfaces](https://en.wikipedia.org/wiki/Abstraction_of_interfaces): Definir interfaces claras y bien documentadas para interactuar con otros sistemas de manera estándar. <br> - [Principio de adhesión a estándares](https://en.wikipedia.org/wiki/Standard_compliance): Utilizar protocolos y formatos de datos comunes para facilitar la interoperabilidad con otros sistemas. |
| Adaptabilidad       | - [Principio de inversión de dependencias (DIP)](https://en.wikipedia.org/wiki/Dependency_inversion_principle): Permitir que los módulos dependan de abstracciones en lugar de implementaciones concretas, lo que facilita la sustitución y adaptación de componentes. <br> - [Principio de composición sobre herencia](https://en.wikipedia.org/wiki/Composition_over_inheritance): Utilizar composición para agregar funcionalidad y permitir que los objetos cambien de comportamiento en tiempo de ejecución. |
